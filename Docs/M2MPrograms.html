<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head> <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type"><title>Demo Programs that Read and Write MDELite Databases</title></head> <body> <h1 style="text-align: center;"><span style="font-family: Helvetica,Arial,sans-serif;">Programs that Read and Write MDELite Databases</span></h1> <span style="font-family: Helvetica,Arial,sans-serif;"><br> Start with these imports, not all of which are needed for every program below. &nbsp;They represent the union required to run all demo programs.<br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px; font-weight: bold;"><big>import MDELite.Marquee2Arguments;<br>import PrologDB.Column;<br>import PrologDB.ColumnCorrespondence;<br>import PrologDB.DB;<br>import PrologDB.DBSchema;<br>import PrologDB.ErrorReport;<br>import PrologDB.SubTableSchema;<br>import PrologDB.Table;<br>import PrologDB.toTable;<br>import PrologDB.TableSchema;<br>import PrologDB.Tuple;<br>import java.util.List;<br>import java.util.stream.Collectors;<br>import java.util.stream.Stream;<br></big></pre> <span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;">Later we will use the dog-owner database, shown below:<br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px; font-weight: bold;"><big>dbase(do,[dog,owner,when]).

table(dog,[did,'name','breed', color]).
dog(d1,'kelsey','aussie',bluemerle).
dog(d2,'lassie','collie',sable).
dog(d3,'scarlett','aussie',blacktri).
dog(d4,'duke','hound dog',brown).
dog(d5,'scarlett','aussie',bluemerle).

table(owner,[oid,'name']).
owner(o1,'timmy').
owner(o2,'don').
owner(o3,'helen').
owner(o4,'jed').

table(when,[wid,did,oid,'date']).
when(w1,d1,o2,'88-95').
when(w2,d2,o1,'58-71').
when(w3,d3,o3,'07-12').
when(w4,d3,o2,'12-').
when(w5,d4,o4,'58-69'). </big></pre> <span style="font-family: Helvetica,Arial,sans-serif; font-weight: bold;">Table of Contents</span><br style="font-family: Helvetica,Arial,sans-serif;"><ol style="font-family: Helvetica,Arial,sans-serif;"><li><a href="#Writing_a_M2M_Transformation">Writing an M2M Transformation</a></li><li><a href="#Program_1:_Printing_a_Database_Schema">Printing a Database Schema</a></li><li><a href="#Program_2_:_Constructing_Schemas">Constructing Schemas</a></li><li><a href="#Program_5:_Programmatically_Creating_a">Creating a Database</a></li><li><a href="#Program_3:_Programmatically_Reading_a">Reading a Database</a></li><li><a href="#Program_4:_Programmatically_Reading_a">Reading a Table</a></li><li><a href="#Program_6:_Programmatically_Reading">Reading Tuples of a Table and its Subtables</a></li><li><a href="#Program_10:_Filtering_Tuples_from">Filtering Tuples from Tables</a></li><li><a href="#GroupBy">Group By Queries</a></li><li><a href="#Program_7:_Taking_Cross_Products_of">Taking Cross Products of Schemas</a></li><li><a href="#Program_8:_Table_Joins">Table Joins</a></li><li><a href="#Program_9:_Self_Joins">Self Joins</a></li><li><a href="#Program_12:_Reading_and_Writing">Reading and Writing Individual Prolog and CSV Tables</a></li><li><a href="#CollectingStreamedTuples">Collecting Streamed tuples into a Table</a></li><li><a href="#15:_Copying_Data_from_a_Tuple_of_one">Copying data from a Tuple of one Schema to Another</a></li><li><a href="#16:_Sorting_Tables">Sorting Tables</a></li></ol><hr style="width: 100%; height: 2px;"><h2><a name="Writing_a_M2M_Transformation"></a><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">1: Writing a M2M Transformation</span></span></h2><span style="color: rgb(0, 0, 0); font-family: Helvetica,Arial,sans-serif; font-size: medium; font-style: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; display: inline ! important; float: none;">All MDELite Model-to-Model (or database-to-database) transformation programs have the following prelude and structure:</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><pre style="margin-left: 40px; font-weight: bold;"><big><span style="font-family: monospace;">public class DocExamplesTest {<br><br>    public static void main(String... args) throws Exception {<br>        // Step 1: boilerplate initialization<br>        Marquee2Arguments mark = new Marquee2Arguments(DocExamplesTest.class, ".do.pl", ".pet.pl", args);<br>        String inputFileName = mark.getInputFileName();<br>        String outputFileName = mark.getOutputFileName();<br>        String appName = mark.getAppName(outputFileName);<br><br>        // Step 2: read database<br>        DB db = DB.readDataBase(inputFileName);<br>        Table dog = db.getTableEH("dog");<br>        Table own = db.getTableEH("owner");<br>        //...<br><br>        // Step 3: read schema<br>        DBSchema dbs = DBSchema.readSchema("pet.schema.pl");<br>        DB petdb = new DB(appName, dbs);<br>        Table pet = petdb.getTableEH("pet");<br>        Table owner = petdb.getTableEH("owner");<br>        //...<br><br>        // Step 4:now translate databasses<br>        //...<br>        // Finally, write out pet database<br>        petdb.print(outputFileName);<br>    }<br></span></big></pre><span style="font-family: Helvetica,Arial,sans-serif;">The first step executes boilerplate code to process the command line. &nbsp;This particular M2M program translates ".do.pl" database to ".pet.pl" databases. &nbsp;That is, to invoke the above program you would type:<br></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><pre style="margin-left: 40px;"><span style="font-family: monospace;"><big style="font-weight: bold;">&gt; java DocExamplesTest  X.do.pl<br>or<br>&gt; java DocExamplesTest  X.do.pl   output.tx</big><span style="font-weight: bold;">t</span><br></span></pre><span style="font-family: Helvetica,Arial,sans-serif;">The first call will produce pet database file <span style="font-weight: bold;">X.pet.pl</span>. &nbsp;That is, given <span style="font-weight: bold;">X.do.pl</span> as input, the translated database will be named <span style="font-weight: bold;">X.pet.pl</span>. The second call will ignore the standard output (<span style="font-weight: bold;">X.pet.pl</span>) and will produce its contents in file <span style="font-weight: bold;">output.txt</span>. Other points worth noting are variables:<br></span><ul><li><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">inputFileName</span> -- the name of the input database (<span style="font-weight: bold;">X.do.pl</span>)</span></li><li><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">outputFileName</span> -- the name of the output database (<span style="font-weight: bold;">X.pet.pl</span>) or whatever is specified on the command line (e.g. output.txt)</span></li><li><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">appName</span> -- if "<span style="font-weight: bold;">X.do.pl</span>" is the input database, <span style="font-weight: bold;">appName</span> = "<span style="font-weight: bold;">X</span>".<br></span></li></ul><span style="font-family: Helvetica,Arial,sans-serif;">The second step reads the input database (whose name is in variable inputFileName), and extracts its tables.<br><br>The third step is to read the schema for the pet database, in this case it is file "pet.schema.pl" which is local file or a file that is hardwired to a particular directory. &nbsp;It is also possible to hardwire the contents of a schema as amultiline String which is in the program itself. &nbsp;To do this, use:<br></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><pre style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;"></span><big><span style="font-weight: bold;">String defOfSchema = "dbase(a,[b,c]).\ntable(b,[id,x,y]).\ntable(c,[z]).\nsubtable(b,[c]).";</span><br style="font-weight: bold;"><span style="font-weight: bold;">DBSchema sch = DBSchema.readSchema("a",defOfSchema);</span></big></pre><span style="font-family: Helvetica,Arial,sans-serif;">Also part of the third step is to create an empty pet database.<br><br>The rest of the program is code to translate a ".do.pl" database into a pet database. &nbsp;The end of the program writes the produced database to its output file.<br><br>The following examples illustrate how to read, write, and create MDELite databases.<br></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="Program_1:_Printing_a_Database_Schema"></a>2:&nbsp;Printing a Database Schema</h2> <span style="font-family: Helvetica,Arial,sans-serif;">This program takes an ooschema declaration and flattens it into a schema declaration. &nbsp;The distinction between ooschemas and schemas is that attributes of supertables are propagated to each of its subtables, recursively. &nbsp;The program prints a database schema one table at a time. &nbsp;Printing subtable declarations of the database conclude the program.<br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px;"><big style="font-weight: bold;">    void printSchema() throws Exception {<br>        // Step 1: read in ooschema and propagate attributes to convert it<br>        //         into a .schema file, so that it can be instantiated<br>        DBSchema s = DBSchema.readSchema(testdir + "starTrek.ooschema.pl");<br>        s.finishAndPropagateAttributes();<br><br>        // Step 2: easy way to print a schema<br>        s.print(System.out);<br><br>        // Step 3: harder, but customized<br>        System.out.format("\n=========\n\n");<br>        System.out.format("database %s has \n", s.getName());<br>        for (TableSchema t : s.getTableSchemas()) {<br>            System.out.format("   table %10s with columns ", t.getName());<br>            for (Column c : t.getColumns()) {<br>                String quote = c.isQuoted() ? "\'" : "";<br>                System.out.format("%s%s%s ", quote, c.getName(), quote);<br>            }<br>            System.out.format("\n");<br>        }<br>        System.out.format("\n");<br>        for (SubTableSchema st : s.getSubTableSchemas()) {<br>            TableSchema supr = st.getSuper();<br>            System.out.format("   table %10s has subtables ", supr.getName());<br>            for (TableSchema chld : st.getSubTableSchemas()) {<br>                System.out.format("%s ", chld.getName());<br>            }<br>            System.out.format("\n");<br>        }<br>    }<br></big> </pre> <span style="font-family: Helvetica,Arial,sans-serif;"> Here is the output of this program:<br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px; font-weight: bold;"><big>dbase(starTrek,[crewman,commander,lieutenant]).

table(crewman,[cid,fname,lname]).
table(commander,[cid,fname,lname,rank]).
table(lieutenant,[cid,fname,lname,specialty]).

subtable(crewman,[commander,lieutenant]).

=========

database starTrek has 
   table    crewman with columns cid fname lname 
   table  commander with columns cid fname lname rank 
   table lieutenant with columns cid fname lname specialty 

   table    crewman has subtables commander lieutenant </big></pre> <hr style="width: 100%; height: 2px;"><h2><a name="Program_2_:_Constructing_Schemas"></a><span style="font-family: Helvetica,Arial,sans-serif;">3: Constructing Schemas</span></h2> <span style="font-family: Helvetica,Arial,sans-serif;">This program creates a starTrek ooschema programmatically and prints it out using standard utilities. &nbsp;Different ways of creating a table schema are shown.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px;"><big style="font-weight: bold;">    DBSchema schemaBuild() throws Exception {<br>        // Step 1: when a schema is initially created, and until it is<br>        //         "finished", it is an .ooschema<br>        DBSchema trekSchema = new DBSchema("starTrek");<br><br>        //  Step 2: add tables<br>        TableSchema crewman = new TableSchema("crewman");<br>        crewman.addColumns("cid", "fname", "lname");<br>        TableSchema commander = new TableSchema("commander").addColumn("rank");<br>        TableSchema lieutenant = new TableSchema("lieutenant").addColumn("specialty");<br><br>        trekSchema.addTableSchemas(crewman, commander, lieutenant);<br><br>        //  Step 3: create the lone subtable declaration, and add to schema<br>        SubTableSchema sts = new SubTableSchema(crewman);<br>        sts.addSubTableSchemas(commander, lieutenant);<br>        trekSchema.addSubTableSchema(sts);<br><br>        // Step 4: seal or "finish" the schema so that no further editing of it <br>        //         is possible; propagate supertable attributes to subtables.<br>        trekSchema.finishAndPropagateAttributes();<br><br>        // return the DBSchema "starTrek.schema.pl"<br>        return trekSchema;<br>    }<br></big><br></pre> <hr style="width: 100%; height: 2px;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="Program_5:_Programmatically_Creating_a"></a>4: Creating a Database</h2> <span style="font-family: Helvetica,Arial,sans-serif;">This program creates the enterprise database which has 3 tuples, one tuple per table. &nbsp;An ooschema for the database is created and then converted into a true schema (shown above). &nbsp;At this point, a database instance of the schema can be created, one table and one tuple at a time. &nbsp;Different ways of creating a tuple are shown.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br> </span><pre style="margin-left: 40px; font-weight: bold;"><big>    void DBBuild() throws Exception {<br>        // Step 1: build the starTrek schema and then instantiate it with <br>        //         an empty database<br>        DBSchema trekSchema = schemaBuild();  // see schemaBuild() defn above<br>        DB enterprise = new DB("enterprise", trekSchema);<br><br>        // Step 2: create the spock tuple<br>        Table crewman = enterprise.getTableEH("crewman");<br>        Tuple spock = new Tuple(crewman);<br>        spock.setValues("c1", "mr", "spock");<br>        crewman.add(spock);<br><br>        //  Step 3: create the sulu tuple<br>        Table lieutenant = enterprise.getTableEH("lieutenant");<br>        Tuple sulu = new Tuple(lieutenant).setValues("c3", "hikaru", "sulo", "navigation");<br>        lieutenant.add(sulu);<br><br>        //  Step 4: create the kirk tuple<br>        Table commander = enterprise.getTableEH("commander");<br>        commander.add(new Tuple(commander).setValues("c2", "james", "kirk", "captain"));<br><br>        //  Step 5: now print database<br>        enterprise.print(System.out);<br>    }<br><span style="font-family: Helvetica,Arial,sans-serif;"></span> </big></pre> <span style="font-family: Helvetica,Arial,sans-serif;">Here is the output of this program:<br> </span><pre style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;"></span><big style="font-weight: bold;">dbase(starTrek,[crewman,commander,lieutenant]).

table(crewman,[cid,fname,lname]).
crewman(c1,mr,spock).

table(commander,[cid,fname,lname,rank]).
commander(c2,james,kirk,captain).

table(lieutenant,[cid,fname,lname,specialty]).
lieutenant(c3,hikaru,sulo,navigation).

subtable(crewman,[commander,lieutenant]). </big><br></pre><hr style="width: 100%; height: 2px;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="Program_3:_Programmatically_Reading_a"></a>5: Reading a Database</h2> <span style="font-family: Helvetica,Arial,sans-serif;">This program reads a database given its file, prints the database using available utilities and also a harder way by extracting out its individual tables and printing its tuples.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px;"><big style="font-weight: bold;">    void DBread() throws Exception {<br>        // Step 1: read a database given its file<br>        DB db = DB.readDataBase(testdata + "/enterprise.starTrek.pl");<br><br>        // Step 2: easy way to print a database<br>        db.print(System.out);<br><br>        // Step 3: a more customized way<br>        System.out.format("\n\n ===== \n\n");<br>        System.out.format("database %s contains:\n", db.getName());<br><br>        for (Table t : db.getTables()) {<br>            System.out.format("Table %s\n", t.getName());<br>            t.stream().forEach(tup -> tup.print(System.out));<br>            System.out.format("\n");<br>        }<br>    }<br> </big><br></pre> <span style="font-family: Helvetica,Arial,sans-serif;">Here is the output of this program:<br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px; font-weight: bold;"><big>dbase(starTrek,[crewman,commander,lieutenant]).

table(crewman,[cid,fname,lname]).
crewman(c1,mr,spock).

table(commander,[cid,fname,lname,rank]).
commander(c2,james,kirk,captain).

table(lieutenant,[cid,fname,lname,specialty]).
lieutenant(c3,hikaru,sulu,navigation).

subtable(crewman,[commander,lieutenant]).


 ===== 

database enterprise contains:
Table crewman
crewman(c1,mr,spock).
commander(c2,james,kirk,captain).
lieutenant(c3,hikaru,sulu,navigation).

Table commander
commander(c2,james,kirk,captain).

Table lieutenant
lieutenant(c3,hikaru,sulu,navigation). </big></pre><hr style="width: 100%; height: 2px;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="Program_4:_Programmatically_Reading_a"></a>6: Reading a Table</h2> <span style="font-family: Helvetica,Arial,sans-serif;">This program reads a dog-owner database, which has a table of dogs. &nbsp;Using Java Streams, the stream of all aussie (Australian Shepherd) tuples is created and then printed. &nbsp;A similar stream is reconstituted (remember: once you use a stream, it's done and has to be recreated) and then filtered further, and printed.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px; font-weight: bold;"><big>    void TableRetrieve() {<br>        // Step 1: read the database containing desired table, and get the table<br>        DB db = DB.readDataBase(testdata + "/dogOwner.do.pl");<br>        Table dog = db.getTable("dog");<br><br>        // Step 2: retrieve all aussies -- version 1 tuple streams<br>        dog.stream().filter(t -> t.is("breed", "aussie"))<br>                .forEach(t -> t.print(System.out));<br>        System.out.println();<br><br>        // Step 3: retrieve all aussies -- version 2 tables<br>        dog.filter(t -> t.is("breed", "aussie")).print(System.out);<br><br>        // Step 4: retrieve all aussies that are blacktri's -- version 1 <br>        Stream<Tuple> aussies = dog.stream().filter(t -> t.is("breed", "aussie"));<br>        Stream<Tuple> cuteAussies = aussies.filter(t -> t.is("color", "blacktri"));<br>        cuteAussies.forEach(t -> t.print(System.out));<br>        System.out.println();<br><br>        // Step 5: another version, this time using Tables -- version 2<br>        dog.filter(t -> t.is("breed", "aussie") && t.is("color", "blacktri"))<br>                .print(System.out);<br>    }<br></big></pre><hr style="width: 100%; height: 2px;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="Program_6:_Programmatically_Reading"></a>7: Reading Tuples of a Table and its Subtables</h2> <span style="font-family: Helvetica,Arial,sans-serif;">This program reads the tuples of the table pet and all of its subtables. &nbsp;If you want to retrieve tuples of only that table (and not its subtables), use the getLocalTuples() method. &nbsp;A couple queries are illustrated. &nbsp; </span><span style="font-family: Helvetica,Arial,sans-serif;"><br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px;"><big style="font-weight: bold;">    void InheritanceRetrieve() {<br>        // Step 1 : read the database and get the pet table<br>        DB db = DB.readDataBase(testdata + "/pets.petdb.pl");<br>        Table pet = db.getTableEH("pet");<br><br>        // Step 1: easy way: print all pets in pet table and subtables<br>        pet.print(System.out);<br><br>        // Step 2: a more verbose way:<br>        pet.getSchema().print(System.out);<br>        pet.tuples().forEach(t -> t.print(System.out));<br><br>        // Step 3: all pets whose name begins with "l" -- streaming version<br>        System.out.println("\nlist of all pets whose name starts with 'l'");<br>        pet.filter(t -> t.get("name").startsWith("l")).print(System.out);<br><br>        // Step 4: all pets whose name begins with "l" -- table version<br>        System.out.println("\nversion 2");<br>        Table shorterPet = pet.filter(t -> t.get("name").startsWith("l"));<br>        shorterPet.print(System.out);<br>    }<br> </big><br></pre><hr style="width: 100%; height: 2px;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="Program_10:_Filtering_Tuples_from"></a>8: &nbsp;Filtering Tuples from Tables</h2> <span style="font-family: Helvetica,Arial,sans-serif;">This program illustrates several ways in which you can filter tuples from tables. &nbsp; The first uses a loop with an if-statement. &nbsp;The second creates a stream of tuples that are filtered and printed. The third creates a table of only filtered tuples that is then printed. &nbsp;The only difference between the latter&nbsp;two is that stream implementations process one tuple at a time as opposed to one table at a time.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br> </span><pre style="margin-left: 40px; font-weight: bold;"><big>    public void filter() {<br>        DB db = DB.readDataBase(testdata + "/enterprise.starTrek.pl");<br>        Table crew = db.getTableEH("crewman");<br><br>        // Step 1: easy way using tables<br>        Predicate<Tuple> p = t -> t.get("fname").startsWith("h");<br>        crew.filter(p).print(System.out);<br><br>        // Step 2: more manual via loops<br>        crew.getSchema().print(System.out);<br>        for (Tuple t : crew.tuples()) {<br>            if (t.get("fname").startsWith("h")) {<br>                t.print(System.out);<br>            }<br>        }<br>        System.out.println();<br><br>        // Step 3: another way using streams<br>        crew.getSchema().print(System.out);<br>        crew.stream()<br>                .filter(t -> t.get("fname").startsWith("h"))<br>                .forEach(t -> t.print(System.out));<br>    }<br></big></pre><span style="font-family: Helvetica,Arial,sans-serif;">Here is the output of this program:</span><br> <pre style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><big style="font-weight: bold;"><span style="font-family: monospace;">table(crewman,[cid,fname,lname]).
lieutenant(c3,hikaru,sulu,navigation).

table(crewman,[cid,fname,lname]).
lieutenant(c3,hikaru,sulu,navigation).

table(crewman,[cid,fname,lname]).
lieutenant(c3,hikaru,sulu,navigation). </span></big></pre><span style="font-family: monospace;"></span> <hr style="width: 100%; height: 2px;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="GroupBy"></a>9: Group By Queries<br></h2><span style="font-family: Helvetica,Arial,sans-serif;">This program illustrates group-by facilities. &nbsp;A table is "grouped by" a particular column, producing a stream of subtables (of the same type as the original table) containing all tuples that have the same column value.&nbsp;<br></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><pre style="margin-left: 40px;"><big style="font-weight: bold;">    void GroupBy() {<br>        DB db = DB.readDataBase(testdata + "dogOwner.do.pl");<br>        Table dog = db.getTableEH("dog");<br><br>        // Step 1: one way -- print directly to standard out<br>        dog.groupBy("breed").forEach(tb -> System.out.format("%d %s\n", tb.count(), tb.getFirst(p -> true).get("breed")));<br><br>        // Step 2: collect into a separate table and print that table<br>        Table result = new Table(new TableSchema("result").addColumns("count", "breed"));<br>        dog.groupBy("breed")<br>                .forEach(tb -> result.addTuple(tb.count() + "", tb.getFirst(p -> true).get("breed")));<br>        result.print(System.out);<br>    }<br></big><br></pre><hr style="width: 100%; height: 2px;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="Program_7:_Taking_Cross_Products_of"></a>10: Taking Cross Products of SchemasCopying data from a Tuple of one Schema to Another</h2> <span style="font-family: Helvetica,Arial,sans-serif;">Table joins take cross products of schemas automatically. &nbsp;Occasionally you might need to do this yourself. &nbsp;The following program illustrates how cross products of schemas are taken and printed.</span><br> <span style="font-family: Helvetica,Arial,sans-serif;"> </span> <pre style="margin-left: 40px;"><big style="font-weight: bold;">    public void crossSchema() {<br>        // Step 1: although this is a database file, you can still use it<br>        //         to read its schema.  Then read and print the dog and <br>        //         owner table schemas<br>        DBSchema dbs = DBSchema.readSchema(testdata + "/dogOwner.do.pl");<br>        TableSchema dog = dbs.getTableSchema("dog");<br>        TableSchema owner = dbs.getTableSchema("owner");<br><br>        dog.print(System.out);<br>        owner.print(System.out);<br><br>        // Step 2: here is where the cross-product of two schemas is taken<br>        TableSchema dXoSchema = dog.crossProduct(owner);<br>        dXoSchema.print(System.out);<br><br>        // Step 3: take cross product of all 3 schemas, 2 at a time<br>        TableSchema when = dbs.getTableSchema("when");<br>        when.print(System.out);<br>        TableSchema dogXwhen = dog.crossProduct(when);<br>        dogXwhen.print(System.out);<br>        TableSchema dogXwhenXowner = dogXwhen.crossProduct(owner);<br>        dogXwhenXowner.print(System.out);<br>    }<br></big><span style="font-weight: bold;"> </span><br></pre> <span style="font-family: Helvetica,Arial,sans-serif;">Here is the output of this program:</span><br> <pre style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><big style="font-weight: bold;">BEGIN cross schema tests 

table(dog,[did,"name","breed",color]).
table(owner,[oid,"name"]).
table(dog_x_owner,[dog.did,"dog.name","dog.breed",dog.color,owner.oid,"owner.name"]).
table(when,[wid,did,oid,"date"]).
table(dog_x_when,[dog.did,"dog.name","dog.breed",dog.color,when.wid,when.did,when.oid,"when.date"]).
table(dog_x_when_x_owner,[dog.did,"dog.name","dog.breed",dog.color,when.wid,when.did,when.oid,"when.date",owner.oid,"owner.name"]).

END cross schema tests </big></pre> <hr style="width: 100%; height: 2px;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="Program_8:_Table_Joins"></a>11: Table Joins</h2> <span style="font-family: Helvetica,Arial,sans-serif;">This program reads a dog-owner database, finds the dog, when, and owner tables, joins the dog table with the when table over dog.did = when.did join predicate (i.e., the did columns of both tuples must have the same value) to produce a new table dogXwhen. &nbsp;<br> <br> </span> <div style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;">Note: the attributes of the joined relation are renamed. &nbsp;What used to be attribute T in the dog table is now renamed dog.T. &nbsp;Same for all other attributes, so that one can always distinguish attributes with similar names. Continuing, this table is printed, and then it is joined with the owner table over predicate when.oid = owner.oid, and then the table is printed out.</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><br> <span style="font-family: Helvetica,Arial,sans-serif;"></span></div> <span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px;"><big style="font-weight: bold;">    void TableJoins() {<br>        // Step 1: read the dog-owner database and get its tables to join<br>        DB db = DB.readDataBase(testdata + "/dogOwner.do.pl");<br>        Table dog = db.getTable("dog");<br>        Table when = db.getTable("when");<br>        Table owner = db.getTable("owner");<br><br>        // Step 2: join dog with when (over fields named "did"). Note: the <br>        //         fields of dogXwhen table are renamed to when.did, when.oid, <br>        //         when.date, dog.did, dog.name, dog.breed, and dog.color<br>        Table dogXwhen = dog.join("did", when, "did");<br>        dogXwhen.print(System.out);<br><br>        // Step 3: join dogXwhen with the ownere table<br>        Table dogXwhenXowner = dogXwhen.join("when.oid", owner, "oid");<br>        dogXwhenXowner.print(System.out);<br>    }<br></big><span style="font-weight: bold;"> </span><br></pre> <span style="font-family: Helvetica,Arial,sans-serif;">Here is the output of this program:</span><br> <pre style="margin-left: 40px;"><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><big style="font-weight: bold;"><span style="font-family: monospace;">table(dog_x_when,[dog.did,"dog.name","dog.breed",dog.color,when.wid,when.did,when.oid,"when.date"]).
dog_x_when(d1,'kelsey','aussie',bluemerle,w1,d1,o2,'88-95').
dog_x_when(d2,'lassie','collie',sable,w2,d2,o1,'58-71').
dog_x_when(d3,'scarlett','aussie',blacktri,w3,d3,o3,'07-12').
dog_x_when(d3,'scarlett','aussie',blacktri,w4,d3,o2,'12-').
dog_x_when(d4,'duke','hound dog',brown,w5,d4,o4,'58-69').

table(dog_x_when_x_owner,[dog.did,"dog.name","dog.breed",dog.color,when.wid,when.did,when.oid,"when.date",owner.oid,"owner.name"]).
dog_x_when_x_owner(d1,'kelsey','aussie',bluemerle,w1,d1,o2,'88-95',o2,'don').
dog_x_when_x_owner(d2,'lassie','collie',sable,w2,d2,o1,'58-71',o1,'timmy').
dog_x_when_x_owner(d3,'scarlett','aussie',blacktri,w3,d3,o3,'07-12',o3,'helen').
dog_x_when_x_owner(d3,'scarlett','aussie',blacktri,w4,d3,o2,'12-',o2,'don').
dog_x_when_x_owner(d4,'duke','hound dog',brown,w5,d4,o4,'58-69',o4,'jed'). </span></big><span style="font-family: Courier New,Courier,monospace;"></span></pre> <hr style="width: 100%; height: 2px;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="Program_9:_Self_Joins"></a>12: Self Joins</h2> <span style="font-family: Helvetica,Arial,sans-serif;">Here is a program that joins the dog table with itself over dog identifiers (did). &nbsp;The key to self-joins is that a copy of a table for each self-join must be made. &nbsp;If a dog table is to be joined with itself, the dog table is really joined with a copy. &nbsp;If a dog table is to be joined with itself, followed by itself, the dog table and two distinct copies of the dog table must be joined. &nbsp;Now, this particular example, of joining a dog table with itself isn't particularly useful, but when you have a table that encodes (parent, child) relationships, joining such tables multiple times allows you to relate parents to grandchildren, and so on.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px;"><big style="font-weight: bold;">    void selfJoin() {<br>        //  Step 1: as usual, read a database and get the dog table and<br>        //          copy it.<br>        DB db = DB.readDataBase(testdata + "/dogOwner.do.pl");<br>        Table dog = db.getTable("dog");<br>        Table dog2 = dog.copyForSelfJoins("dog2");<br><br>        // Step 2: join tables.  The resulting table has 8 fields:<br>        //         dog.did, dog.name, dog.breed, dog.color and<br>        //         dog2.did, dog2.name, dog2.breed, and dog2.color<br>        Table dogXdog2 = dog.join("did", dog2, "did");<br>        dogXdog2.print(System.out);<br>    }<br></big><span style="font-family: Helvetica,Arial,sans-serif;"></span> </pre><hr style="width: 100%; height: 2px;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="Program_12:_Reading_and_Writing"></a>13: &nbsp;Reading and Writing Individual Prolog and CSV Tables</h2> <span style="font-family: Helvetica,Arial,sans-serif;">You can read and write individual tables, either in the standard Prolog format or as a CSV (comma separated value) file. &nbsp;The name of the file (whether it ends or not in ".csv") determines whether the file is to be read/written as a CSV file.<br> </span> <pre style="margin-left: 40px;"><big style="font-weight: bold;"><br>    public void csvfile() {<br>        Table csv = Table.readTable("test/DML/PrologDB/TestData/simple.csv");<br>        csv.writeTable("simple.pl");<br>        csv.writeTable("simple.csv");<br>    }<br></big><br></pre><span style="font-family: Helvetica,Arial,sans-serif;">Here is the <span style="font-weight: bold;">simple.csv</span> file -- all CSV tables are assumed to have quoted attributes (and hence quoted values):</span><span style="font-family: Helvetica,Arial,sans-serif;"><br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px; font-weight: bold;"><big>Id,ab,cd
i1,ab,cd
i2,ef,gh
i3,ij,kl </big></pre><span style="font-family: Helvetica,Arial,sans-serif;">And here it's Prolog formatted output:<br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px;"><big style="font-weight: bold;">table(simple,["Id","ab","cd"]).
simple('i1','ab','cd').
simple('i2','ef','gh').
simple('i3','ij','kl'). </big><br></pre><span style="font-family: Helvetica,Arial,sans-serif;">And what it looks like written out:</span><span style="font-family: Helvetica,Arial,sans-serif;"><br> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <pre style="margin-left: 40px;"><big><span style="font-weight: bold;">Id,ab,cd
i1,ab,cd
i2,ef,gh
i3,ij,kl </span><br></big></pre><hr style="width: 100%; height: 2px;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="CollectingStreamedTuples"></a>14: Collecting Streamed Tuples into a Table</h2><span style="font-family: Helvetica,Arial,sans-serif;">This program shows how a stream of tuples can be collected into table, and then the collected table is compared with the original (and found to be the same).<br></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><pre style="margin-left: 40px;"><big style="font-weight: bold;">    void toTable() {<br>        DB db = DB.readDataBase(testdata + "dogOwner.do.pl");<br>        Table dog = db.getTableEH("dog");<br><br>        // Step 1: stream dog, and collect into a new dog table <br>        Table dog2 = dog.stream().collect(new toTable(dog));<br>        System.out.format("dog2 %s dog", dog2.equals(dog) ? "=" : "!=");<br>    }<br></big><br></pre><hr style="width: 100%; height: 2px;"><h2><a name="15:_Copying_Data_from_a_Tuple_of_one"></a><span style="font-family: Helvetica,Arial,sans-serif;">15: Copying Data from a Tuple of one Schema to Another</span></h2><span style="font-family: Helvetica,Arial,sans-serif;">One of the typical tasks is copying data from one tuple of one schema to a tuple of another. &nbsp;It's not hard, but it is tedious. &nbsp;Look at the first step of the code below -- it is a series of (tedious) assignment statement. &nbsp;The second step defines a ColumnCorrespondence among the fields of the left schema with fields or computations in the right. &nbsp;Not all fields of the left schema need be considered/updated in a correspondence. &nbsp;Also, when a correspondence is defined, it can be subsequently changed by adding and deleting column correspondences. <br></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><pre style="margin-left: 40px;"><big style="font-weight: bold;"><span style="font-family: monospace;">        boolean debug = true;<br>        // Step 1: manual way<br>        for (Tuple b : buckeyes.tuples()) {<br>            Tuple l = new Tuple(longhorns);<br>            l.set("lid", b.get("id").replace("b", "l"));<br>            l.set("name", b.get("fname") + " " + b.get("lname"));<br>            l.set("pos", b.get("position"));<br>            if (debug) {<br>                l.isComplete();<br>            }<br>            longhorns.add(l);<br>        }<br>        longhorns.print();<br><br>        // Step 2: using correspondences<br>        longhorns.deleteAll();<br>        ColumnCorrespondence c = new ColumnCorrespondence()<br>                .add("lid", b -> b.get("id").replace("b", "l"))<br>                .add("name", b -> b.get("fname") + " " + b.get("lname"))<br>                .add("pos", "position");<br>        longhorns.addTuples(buckeyes, c);<br>        longhorns.print();<br><br></span></big><big style="font-weight: bold;"><span style="font-family: monospace;"></span></big></pre><span style="font-family: Helvetica,Arial,sans-serif;">As an aside, the manual way has a debug option that tests if a tuple is complete -- this means that a tuple has its full complement of column-value pairs. &nbsp;In this example all longhorn tuples do. &nbsp;If a tuple is incomplete, an RuntimeException is thrown. &nbsp;This is a way that you can debug a program -- and once you're convinced you have all columns, you can remove the isComplete test.</span><br><span style="font-family: Helvetica,Arial,sans-serif;"></span><hr style="width: 100%; height: 2px;"><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="16:_Sorting_Tables"></a>16: Sorting Tables</h2><span style="font-family: Helvetica,Arial,sans-serif;">Sorting is obvious. &nbsp;Let T be a table with column "key". &nbsp;What does T.sort("key") produce? Clearly a sorted table. &nbsp;But do we want a sorted copy of T to be output, or do we want T itself to be sorted? &nbsp;That's the purpose of sort(table,boolean). &nbsp;If the boolean is true, the input table is updated by being sorted. &nbsp;If false, a sorted copy of T is produced.<br></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><pre style="margin-left: 40px;"><span style="font-family: monospace;"><big style="font-weight: bold;">        // sort the longhorn table (in place)<br>        longhorns.sort("lid", true);<br></big><br></span></pre><hr style="width: 100%; height: 2px;"><pre style="margin-left: 40px;"><span style="font-family: monospace;"></span></pre><span style="font-family: Helvetica,Arial,sans-serif;"><br></span><span style="font-family: Helvetica,Arial,sans-serif;"></span></body></html> 
