<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type"><title>Comparing MDELite with ATL's Families to Persons Demo</title></head> <body> <h1 style="text-align: center;"><span style="font-family: Helvetica,Arial,sans-serif;">Comparing MDELite with ATL's Families to Persons Demo</span></h1> <span style="font-family: Helvetica,Arial,sans-serif;"><br><span style="font-family: Helvetica,Arial,sans-serif;">The Atlas Transformation Language) (ATL) is a first-generation MDE language for writing model-to-model (M2M) transformations. &nbsp;As such it is pioneering work against which all future transformation languages should be compared. &nbsp;We invite readers to visit and digest the ATL example at:<br><br><a href="http://wiki.eclipse.org/ATL/Tutorials_-_Create_a_simple_ATL_transformation">http://wiki.eclipse.org/ATL/Tutorials_-_Create_a_simple_ATL_transformation</a><br><br>Here is how the Familes to Persons example can be implemented in MDELite7. &nbsp;Here is the input database:<br></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></span><pre style="margin-left: 40px;"><big style="font-weight: bold;">dbase(families,[family,member]).

table(family,[id,"lastName",fatherid,motherid]).
family(f1,'March',m1,m2).
family(f2,'Sailor',m5,m6).

table(member,[mid,"firstName",sonOf,daughterOf]).
member(m1,'Jim',null,null).
member(m2,'Cindy',null,null).
member(m3,'Brandon',f1,null).
member(m4,'Brenda',null,f1).

member(m5,'Peter',null,null).
member(m6,'Jackie',null,null).
member(m7,'David',f2,null).
member(m8,'Dylan',f2,null).
member(m9,'Kelly',null,f2).  </big><span style="font-family: Helvetica,Arial,sans-serif;"><br></span></pre><span style="font-family: Helvetica,Arial,sans-serif;">and here is the translated database, the output of the Families2Persons transformation:</span><br><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></span><pre style="margin-left: 40px;"><big style="font-weight: bold;">dbase(persons,[person,male,female]).

table(person,[id,"fullName"]).

table(male,[id,"fullName"]).
male(m1,'Jim March').
male(m5,'Peter Sailor').
male(m3,'Brandon March').
male(m7,'David Sailor').
male(m8,'Dylan Sailor').

table(female,[id,"fullName"]).
female(m2,'Cindy March').
female(m6,'Jackie Sailor').
female(m4,'Brenda March').
female(m9,'Kelly Sailor').

subtable(person,[male,female]). </big><big><br></big></pre><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">In the following sections, I explain the Families2 Persons transformation program:<br><br></span></span><h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">Helper Function</span></span></h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span>Just as the ATL example used a helper function, we do too. &nbsp;It is listed below. &nbsp;It takes a table and a join tuple (which belongs to the cross-product of the member and family database) as input. &nbsp;From the tuple I extract the member's identifer, first name, and last name. &nbsp;The first and last names are concatenated, and to the input table, I add a tuple whose field values are member identifier, first+last name:</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></span><pre style="margin-left: 40px; font-weight: bold;"><big>    static void helper(Table tab, Tuple t) {<br>        String id = t.get("member.mid");<br>        String name = t.get("member.firstName") + " " + t.get("family.lastName");<br>        tab.addTuple(id, name);<br>    }<br></big></pre><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></span><h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></span><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif;">Initialization</span></h2><span style="font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">The command-line input to the program is the input database (whose contents I listed above). &nbsp;Read the command line, extract &nbsp;the input file (database) name, and locate the output schema file:<br></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></span><pre style="margin-left: 40px; font-weight: bold;"><big>        // Step 1: standard marquee processing<br>        Marquee2Arguments mark = new Marquee2Arguments(FamiliesM2M.class,<br>                ".families.pl", ".persons.pl", args);<br>        String inputFileName = mark.getInputFileName();<br>        String outputSchema = correct + "persons.schema.pl";<br></big></pre><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></span><h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">Read in Database Input Tables</span></span></h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span>Next, read in the database, and get the family and member tables:<br></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></span><pre style="margin-left: 40px; font-weight: bold;"><big>        // Step 2: read the families database and their tables<br>        DB in = DB.readDataBase(inputFileName);<br>        Table fam = in.getTableEH("family");<br>        Table mem = in.getTableEH("member");<br></big></pre><h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">Read in Schema and Initialize Empty Output Tables</span></span></h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span>Read in the persons schema, create a new (and empty) database instance of this schema. &nbsp;Get the empty male and female tables in which we are to populate tuples:</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></span><pre style="margin-left: 40px; font-weight: bold;"><big>        // Step 3: create an empty persons database with empty tables<br>        DBSchema outSchema = DBSchema.readSchema(outputSchema);<br>        DB inria = new DB(in.getName(), outSchema);<br>        Table male = inria.getTableEH("male");<br>        Table female = inria.getTableEH("female");<br></big></pre><h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">Perform the Model-to-Model Transformation</span></span></h2><span style="font-family: Helvetica,Arial,sans-serif;">The join of the family and members table connects individuals with their family. &nbsp;Male tuples are fathers and sons of families; Female tuples are mothers and daughers of families.<br>Four lines compute all male and female tuples:</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></span><pre style="margin-left: 40px; font-weight: bold;"><big>        // Step 4: fill in father tuples, mother tuples, son, then daughter<br>        fam.join("fatherid", mem, "mid").forEach(t -> helper(male, t));<br>        fam.join("motherid", mem, "mid").forEach(t -> helper(female, t));<br>        fam.join("id", mem, "sonOf").forEach(t -> helper(male, t));<br>        fam.join("id", mem, "daughterOf").forEach(t -> helper(female, t));<br></big></pre><h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">Print the Persons Database</span></span></h2><span style="font-family: Helvetica,Arial,sans-serif;">Is all that remains to do:</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"></span></span><pre style="margin-left: 40px; font-weight: bold;"><big>        // Step 5: print out database<br>        inria.print(System.out);<br></big></pre><h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">Homework</span></span></h2><span style="font-family: Helvetica,Arial,sans-serif;">Compare our solution to that of ATL. &nbsp;I believe MDELite has the following significant advantages:<br></span><ul><li><span style="font-family: Helvetica,Arial,sans-serif;">MDE programmers don't have to learn yet another langauge to write M2M transformations</span></li><li><span style="font-family: Helvetica,Arial,sans-serif;">MDE programmers don't have to learn yet another language to write Model constraints</span></li><li><span style="font-family: Helvetica,Arial,sans-serif;">MDE programmers don't have to maintain customized language -- the language of MDELite is Java 8, and Oracle does a better job of maintaining Java than any university-based research center could</span></li><li><span style="font-family: Helvetica,Arial,sans-serif;">MDELite relies on fundamental concepts in computer science -- relational databases -- and reduces MDE complexity.<br></span></li></ul><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><br></span> </body></html> 
