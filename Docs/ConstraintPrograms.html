<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><head><meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type"><title>MDELite Constraint Programs</title></head> <body> <h1 style="text-align: center;"><span style="font-family: Helvetica,Arial,sans-serif;">MDELite Constraint Programs</span></h1> <span style="font-family: Helvetica,Arial,sans-serif;"><br><span style="font-family: Helvetica,Arial,sans-serif;">Consider the following database. &nbsp;There is an</span></span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">m-n</span> association between tables <span style="font-weight: bold;">student</span> and <span style="font-weight: bold;">course</span>. &nbsp;Association normalization&nbsp;</span><span style="font-family: Helvetica,Arial,sans-serif;">creates a third table <span style="font-weight: bold;">takes</span> that pairs each <span style="font-weight: bold;">student</span> with each <span style="font-weight: bold;">course</span> that student takes. &nbsp;<br></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><pre style="font-family: monospace; margin-left: 40px; font-weight: bold;"><big><big><big><small><small>dbase(sc,[course,student,takes]).<br><br>table(course,[cid,"name"]).<br>table(student,[sid,"name"]).<br>table(takes,[tid,cid,sid])</small></small></big><big><big><small><small>.</small></small></big></big></big></big></pre><span style="font-family: Helvetica,Arial,sans-serif;">There are many unique structural constraints to be verified in this database:<br></span><ol><li><span style="font-family: Helvetica,Arial,sans-serif;"><a href="#2:_Checking_Field_Value_Uniqueness">No two <span style="font-weight: bold;">students</span> have the same name</a>.</span></li><li><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><a href="#3:_Checking_Non-Null_Fields_">Every <span style="font-weight: bold;">takes</span> tuple has a non-null <span style="font-weight: bold;">student</span> ID and a non-null <span style="font-weight: bold;">course</span> ID</a>.</span></li><li><a href="#4:_Checking_Existence_Constraints"><span style="font-family: Helvetica,Arial,sans-serif;">Every <span style="font-weight: bold;">takes</span> tuple requires its <span style="font-weight: bold;">student</span> ID to correspond&nbsp; to a tuple in the <span style="font-weight: bold;">student</span> table; same for <span style="font-weight: bold;">course</span> ID.</span></a></li><li><a href="#5:_No_Field-value_Combinations_are"><span style="font-family: Helvetica,Arial,sans-serif;">No <span style="font-weight: bold;">takes</span> (cid,sid) is duplicated.</span></a></li></ol><span style="font-family: Helvetica,Arial,sans-serif;">But also some that are application specific:<br></span><ol start="5"><li><a href="#6:_Multi-Table_Constraints_"><span style="font-family: Helvetica,Arial,sans-serif;">The compilers and database courses must have a minimum enrollment of 2 students.</span></a></li><li><span style="font-family: Helvetica,Arial,sans-serif;"><a href="#7:_Multi-Table_Constraints_--_Joins">Every student should take one course.</a><br></span></li></ol><span style="font-family: Helvetica,Arial,sans-serif;">The examples in this document illustrate how each of these constraints can be evaluated.<br><br>Remember, </span><span style="color: rgb(0, 0, 0); font-size: medium; font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; font-family: Helvetica,Arial,sans-serif;">Java Streams are stateless, so one has to create an operation that updates a stateful object which retains the list of errors that have been encountered. &nbsp;This is an <span style="font-weight: bold;">ErrorReport</span> object, whose usage is:<br></span><pre style="margin-left: 40px;"><big><span style="font-weight: bold;">ErrorReport er = new ErrorReport();</span><br style="font-weight: bold;"><br style="font-weight: bold;"><span style="font-weight: bold;">... er.add("this is error1");</span><br style="font-weight: bold;"><span style="font-weight: bold;">... er.add("this is error2");</span><br style="font-weight: bold;"><br style="font-weight: bold;"><span style="font-weight: bold;">er.printReportEH(System.out);  // throw exception if errors are reported</span><br></big></pre><span style="font-family: Helvetica,Arial,sans-serif; font-weight: bold;">Table of Contents</span><br style="font-family: Helvetica,Arial,sans-serif;"><ol style="font-family: Helvetica,Arial,sans-serif;"><li><a href="#1:_Writing_an_MDELite_Constraint_Program">Writing an MDELite Constraint Program</a></li><li><a href="#1:_Checking_Unique_Tuple_IDs">Checking Unique Tuple IDs</a></li><li><a href="#2:_Checking_Field_Value_Uniqueness"> Checking Field Value Uniqueness Constraints</a></li><li><a href="#3:_Checking_Non-Null_Fields_">Checking Non-Null Fields&nbsp;</a></li><li><a href="#4:_Checking_Existence_Constraints">Checking Existence Constraints</a></li><li><a href="#5:_No_Field-value_Combinations_are"> No Field-value Combinations are Duplicate</a></li><li><a href="#6:_Multi-Table_Constraints_"> Multi-Table Constraints&nbsp;</a></li><li><a href="#7:_Multi-Table_Constraints_--_Joins">Multi-Table Constraints -- Joins</a></li></ol><h2 style="font-family: Helvetica,Arial,sans-serif;"><a name="1:_Writing_an_MDELite_Constraint_Program"></a>1: Writing an MDELite Constraint Program</h2><span style="font-family: Helvetica,Arial,sans-serif;">All MDELite Constraint-checking programs have the following prelude and structure:<br></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><pre style="margin-left: 40px; font-weight: bold;"><big><span style="font-family: monospace;">import PrologDB.*;<br><br>public class DocConstraintExamplesTest extends PrologDB.Constraints {<br><br>    public static void main(String... args) {<br>        // Step 1: standard command-line processing<br>        MDELite.Marquee4Conform mark = new MDELite.Marquee4Conform(DocConstraintExamplesTest.class, ".sc.pl", args);<br>        String inputFileName = mark.getInputFileName();<br>        String AppName = mark.getAppName(inputFileName);<br><br>        // Step 2: open database to be validated + get needed tables<br>        DB db = DB.readDataBase(inputFileName);<br>        Table course = db.getTableEH("course");<br>        Table student = db.getTableEH("student");<br>        Table takes = db.getTableEH("takes");<br>        ErrorReport er = new ErrorReport();<br><br>        // Step 3: now perform database checks<br>        //...<br>        // Step 4: finish by reporting collected errors<br>        er.printReportEH(System.out);<br>    }<br></span></big></pre><span style="font-family: Helvetica,Arial,sans-serif;">The first step is to read the command-line arguments. &nbsp;The <span style="font-weight: bold;">Marquee4Conform</span> does the work with the following arguments<br></span><ul><span style="font-family: Helvetica,Arial,sans-serif;"></span><li><span style="font-family: Helvetica,Arial,sans-serif;">the Java class object, which is in this case <span style="font-weight: bold;">DocCons.class</span></span></li><li><span style="font-family: Helvetica,Arial,sans-serif;">the pattern of the databases to process, in this case <span style="font-weight: bold;">".school.pl"</span> is the database suffix. (So accepted database file names are <span style="font-weight: bold;">"X.school.pl"</span>)</span></li><li><span style="font-family: Helvetica,Arial,sans-serif;">the command line arguments, which usualy is <span style="font-weight: bold;">args</span>.</span></li></ul><span style="font-family: Helvetica,Arial,sans-serif;">Next, two values are extracted from the command-lines:<br></span><ul><li style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">inputFileName</span> -- the name of the database file, typically of the form "blah/blah/Blah/X.school.pl"</li><li><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">AppName</span> -- if the above is the input file, then <span style="font-weight: bold;">AppName</span> = "X"</span></li></ul><span style="font-family: Helvetica,Arial,sans-serif;">The second step is to open the database (<span style="font-weight: bold;">inputFileName</span>), extract the tables needed, and to create an error reporter to collect all discovered errors. &nbsp;<br><br>The third step is to evaluate constraints. &nbsp;The examples below show code fragments that implement common constraints.<br><br>The last statement of a Constraint checking program is one of the following:</span><br><ul style="font-family: Helvetica,Arial,sans-serif;"><li><span style="font-weight: bold;">er.printReport(ps)</span> -- print the error report to PrintStream ps; do not terminate program if errors are found</li></ul><span style="font-family: Helvetica,Arial,sans-serif;">or more typically:</span><br style="font-family: Helvetica,Arial,sans-serif;"><ul><li><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">er.printReportEH(ps)</span> -- like printReport(ps) above, except that a RuntimeException is thrown if errors are found, halting any computation in which this constraint program is run.</span></li></ul><h2><a name="1:_Checking_Unique_Tuple_IDs"></a><span style="font-family: Helvetica,Arial,sans-serif;">2: Checking Unique Tuple IDs</span></h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">This is a test that is generally unneeded, given that tuple IDs are generated. &nbsp;Unique is a class whose sole purpose is to register values and report duplicates and null values. &nbsp;A standard use is verifying every <span style="font-weight: bold;">course</span> tuple has a unique ID.<br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace; font-weight: bold;"><big style="font-family: monospace;">        // Step 1: simplest way uses MDELite built-in support<br>        UniqueId(course, er);<br>        <br>        // Step 2: a more general way -- that works for any column<br>        Table dups = course.project(course.getIDName()).duplicates();<br>        //dups.print(System.out);<br>        dups.error(er,"course table has multiple tuples with id='%s'",t->t.getId());<br><br>        // Step 3: a more verbose way<br>        Unique u = new Unique(course, "cid", er);<br>        course.forEach(t -> u.add(t));<br></big></pre><h2><a name="2:_Checking_Field_Value_Uniqueness"></a><span style="font-family: Helvetica,Arial,sans-serif;">3: Checking Field Value Uniqueness Constraints</span></h2><span style="font-family: Helvetica,Arial,sans-serif;">Another common constraint is that&nbsp; a column should have unique values for each tuple in a table, such as </span><span style="font-family: Helvetica,Arial,sans-serif;">no two students have the same name (and that names cannot be null).</span><span style="font-family: Helvetica,Arial,sans-serif;"> Again, a Unique report object is used for this task. </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace; font-weight: bold;"><big>        // Step 1: try Manual way<br>        Unique u = new Unique(student, "name", er);<br>        student.stream().forEach(t -> u.add(t));<br><br>        // Step 2: MDELite built-in support<br>        isUnique(student, "name", er);<br>        <br>        // Step 3: more general way<br>        student.project("name").duplicates()<br>                .error(er,"multiple tuples in student have name='%s'",t->t.get("name"));<br></big></pre><h2><a name="3:_Checking_Non-Null_Fields_"></a><span style="font-family: Helvetica,Arial,sans-serif;">4: Checking Non-Null Fields&nbsp;</span></h2><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">E</span></span><span style="font-family: Helvetica,Arial,sans-serif;">very <span style="font-weight: bold;">takes</span> tuple has a non-null <span style="font-weight: bold;">student</span> ID and a non-null <span style="font-weight: bold;">course</span> ID</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">. A single parameterized method, <span style="font-family: Courier New,Courier,monospace;">testNull</span>, can be used to verify that particular fields of a table are non-null.</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace; font-weight: bold;"><big>        // Step 1: try MDELite built-in support<br>        Predicate<Tuple> cidIsNull = t -> t.isNull("cid");<br>        iftest(takes, cidIsNull, "cid is null", er);<br><br>        Predicate<Tuple> sidIsNull = t -> t.isNull("sid");<br>        iftest(takes, sidIsNull, "sid is null", er);<br><br>        // Step 2: or Manual way<br>        testNull(takes, "cid", er);<br>        testNull(takes, "sid", er);<br><br>        // finish<br>        er.printReportEH(System.out);<br>    }<br><br>    void testNull(Table tab, String fieldName, ErrorReport er) {<br>        tab.filter(t -> t.isNull(fieldName))<br>                .forEach(t -> er.add("%s(%s...) has null %s field",<br>                tab.getName(), t.get("tid"), fieldName));<br>    }<br></big></pre><h2 style="color: rgb(0, 0, 0); font-style: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; font-family: Helvetica,Arial,sans-serif;"><a name="4:_Checking_Existence_Constraints"></a>5: &nbsp;Checking Existence Constraints</h2><span style="font-family: Helvetica,Arial,sans-serif;">An existence constraint asserts a tuple-id value in one table corresponds to an existing tuple in another. Example: the</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">student</span> ID in each <span style="font-weight: bold;">takes</span> tuple corresponds to a tuple in the <span style="font-weight: bold;">student</span> table. &nbsp;Existence is checked by the <span style="font-weight: bold;">exists</span> method of MDELite.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace; font-weight: bold;"><big>        // Step 1: Easy way: MDELite built-in support<br>        isLegit(takes, "cid", course, "cid", er);<br><br>        // Step 2: Manual: one way -- a tuple at a time<br>        takes.filter(t -> (!course.exists("cid", t.get("cid"))))<br>                .forEach(t -> {<br>                    er.add("takes(%s,..) has invalid cid value (%s)",<br>                            t.get("tid"), t.get("cid"));<br>                });<br><br>        // Step 3: Manual: another way -- compute a table of offending tuples<br>        takes.antiSemiJoin("cid", course, "cid")<br>                .forEach(t -> er.add("takes(%s,..) has invalid cid value (%s)",<br>                t.get("tid"), t.get("cid")));<br></big></pre><h2 style="color: rgb(0, 0, 0); font-style: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; font-family: Helvetica,Arial,sans-serif;"><a name="5:_No_Field-value_Combinations_are"></a>6: No Field-Value Combinations are Duplicate</h2><span style="font-family: Helvetica,Arial,sans-serif;">This is a slight variation on unique field values. &nbsp;The trick is to create a virtual field whose value is the concatenation of its underlying multiple concrete fields. &nbsp;Here is how Constraint 4 could be written:</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace; font-weight: bold;"><big>        // Step 1: Easiest way -- first remove nulls<br>        Unique u = new Unique(takes, "combo", er);<br>        takes.filter(t -> !(t.isNull("cid") || t.isNull("sid")))<br>                .forEach(t -> u.add(t, combo(t)));<br><br>        // add artificial error for this example <br>        er.add("------");<br><br>        // Step 2: more verbose way <br>        Unique v = new Unique(takes, "combo", er);<br>        for (Tuple t : takes.tuples()) {<br>            if (t.isNull("cid") || t.isNull("sid")) {<br>                continue;<br>            }<br>            String c = combo(t);<br>            v.add(t, c);<br>        }<br><br>        // finally<br>        er.printReportEH(System.out);<br>    }<br><br>    String combo(Tuple t) {<br>        return "'" + t.get("cid") + "," + t.get("sid") + "'"; // quotes optional<br>    }<br></big></pre><h2><a name="6:_Multi-Table_Constraints_"></a><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span>7: Multi-Table Constraints&nbsp; </span></h2><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">Constraint 5 counts the number of <span style="font-weight: bold;">takes</span> (really <span style="font-weight: bold;">student</span>) tuples enrolled in each database and compiler course and checks that at least 2 students are enrolled. &nbsp;This is the first use of the tuple.map() method which converts a tuple, 'this', into a subtable of existing tuples to which it is related. &nbsp;The number of tuples in this subtable is counted and tested whether or not it is &lt; 2.</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace; font-weight: bold;"><big>        // check constraint<br>        course.filter(t -> t.is("name", "compilers") || t.is("name", "databases"))<br>              .filter(t -> t.join("cid", takes, "cid").count() < 2)<br>              .forEach(t -> er.add("%s course does not have enough students", t.get("name")));<br></big></pre><h2 style="color: rgb(0, 0, 0); font-style: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; font-family: Helvetica,Arial,sans-serif;"><a name="7:_Multi-Table_Constraints_--_Joins"></a>8: Multi-Table Constraints -- Joins</h2><span style="font-family: Helvetica,Arial,sans-serif;">Constraint 6 joins tables <span style="font-weight: bold;">student</span>, <span style="font-weight: bold;">takes</span>, and <span style="font-weight: bold;">courses</span> to evaluate a required condition that every student is enrolled in one course. &nbsp;This constraint is complicated enough to have multiple reasonable implementations. &nbsp;The first is:</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace; font-weight: bold;"><big>        // check constraint<br>        student.forEach(s -> {<br>            Table shortTakes = s.rightSemiJoin("sid", takes, "sid");<br>            Table joined = shortTakes.join("cid", course, "cid");<br>            if (joined.count() == 0) {<br>                er.add("student %s is not taking a course", s.get("name"));<br>            }<br>        });<br></big></pre><span style="font-family: Helvetica,Arial,sans-serif;">The second is:</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><br style="font-family: Courier New,Courier,monospace;"></span></span><pre style="margin-left: 40px; font-family: monospace; font-weight: bold;"><big>        // check constraint<br>        student.filter(s -> s.rightSemiJoin("sid", tc, "takes.sid").count() == 0)<br>                .forEach(s -> er.add("student %s is not taking a course",<br>                s.get("name")));<br></big></pre><br><span style="font-family: Helvetica,Arial,sans-serif;"><br></span> </body></html> 
